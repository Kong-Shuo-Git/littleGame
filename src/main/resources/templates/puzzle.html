<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数字华容道游戏</title>
    <!-- 引入Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入Font Awesome -->
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">

    <!-- 配置Tailwind自定义颜色和字体 -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#10B981',
                        danger: '#EF4444',
                        warning: '#F59E0B',
                        puzzle: {
                            board: '#E5E7EB',
                            tile: '#FFFFFF',
                            active: '#3B82F6'
                        },
                        dark: '#1E293B',
                        light: '#F8FAFC'
                    },
                    fontFamily: {
                        game: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>

    <!-- 自定义工具类 -->
    <style type="text/tailwindcss">
        @layer utilities {
            .puzzle-grid {
                display: grid;
                gap: 4px;
                background-color: theme('colors.puzzle.board');
            }

            .puzzle-tile {
                transition: all 0.2s ease;
                user-select: none;
            }

            .puzzle-tile:hover:not(.empty) {
                transform: scale(1.05);
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            }

            .btn-hover {
                @apply transition-all duration-300 hover:scale-105 active:scale-95;
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-50 to-gray-100 min-h-screen font-game text-dark">
<th:block th:replace="fragments/nav :: nav"></th:block>
<div class="container mx-auto px-4 py-8 max-w-5xl">
    <!-- 游戏标题 -->
    <header class="flex justify-between items-center mb-8">
        <h1 class="text-[clamp(2rem,5vw,3rem)] font-bold text-transparent bg-clip-text bg-gradient-to-r from-primary to-secondary">
            数字华容道
        </h1>
        <!-- 修复返回首页按钮链接 -->
        <a th:href="@{/index}"
           class="bg-primary text-white px-6 py-3 rounded-lg transition-all duration-300 hover:bg-primary/90 hover:shadow-lg flex items-center gap-2">
            <i class="fa fa-home"></i>
            <span>返回首页</span>
        </a>
    </header>

    <!-- 游戏区域 -->
    <main class="flex flex-col lg:flex-row gap-8 items-center lg:items-start">
        <!-- 游戏控制面板 -->
        <div class="w-full lg:w-64 bg-white rounded-xl shadow-lg p-5 flex flex-col gap-4">
            <div class="space-y-3">
                <h2 class="text-xl font-semibold text-dark border-b pb-2">控制</h2>

                <!-- 游戏控制按钮 -->
                <div class="grid grid-cols-2 gap-3">
                    <button id="shuffleBtn"
                            class="bg-secondary text-white py-2 px-4 rounded-lg flex items-center justify-center gap-2 btn-hover">
                        <i class="fa fa-random"></i>
                        <span>打乱</span>
                    </button>
                    <button id="hintBtn"
                            class="bg-primary text-white py-2 px-4 rounded-lg flex items-center justify-center gap-2 btn-hover">
                        <i class="fa fa-lightbulb-o"></i>
                        <span>提示</span>
                    </button>
                </div>

                <!-- 难度选择 -->
                <div class="space-y-2">
                    <h3 class="font-medium text-gray-700">难度</h3>
                    <div class="grid grid-cols-3 gap-2">
                        <button id="mediumBtn" class="bg-gray-200 hover:bg-gray-300 py-1 rounded btn-hover">3×3</button>
                        <button id="hardBtn" class="bg-gray-200 hover:bg-gray-300 py-1 rounded btn-hover">4×4</button>
                        <button id="extremeBtn" class="bg-gray-200 hover:bg-gray-300 py-1 rounded btn-hover">5×5</button>
                    </div>
                </div>

                <!-- 游戏模式 -->
                <div class="space-y-2">
                    <h3 class="font-medium text-gray-700">模式</h3>
                    <div class="grid grid-cols-2 gap-2">
                        <button id="numberModeBtn" class="bg-blue-500 text-white py-1 rounded btn-hover">数字</button>
                        <button id="imageModeBtn" class="bg-gray-200 hover:bg-gray-300 py-1 rounded btn-hover">图片</button>
                    </div>
                </div>

                <!-- 图片上传 -->
                <div id="imageUploadSection" class="space-y-2 hidden">
                    <h3 class="font-medium text-gray-700">选择图片</h3>
                    <input type="file" id="imageInput" accept="image/*" class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                    <div id="imagePreview" class="w-full h-32 bg-gray-100 rounded border-2 border-dashed border-gray-300 flex items-center justify-center text-gray-500 text-sm">
                        选择图片预览
                    </div>
                </div>
            </div>

            <!-- 游戏状态 -->
            <div class="space-y-3">
                <h3 class="font-medium text-gray-700">游戏统计</h3>
                <div class="grid grid-cols-1 gap-3">
                    <div class="bg-gray-100 rounded-lg p-3">
                        <p class="text-sm text-gray-500">步数</p>
                        <p id="moves" class="text-xl font-bold text-primary">0</p>
                    </div>
                    <div class="bg-gray-100 rounded-lg p-3">
                        <p class="text-sm text-gray-500">时间</p>
                        <p id="time" class="text-xl font-bold text-secondary">00:00</p>
                    </div>
                    <div class="bg-gray-100 rounded-lg p-3">
                        <p class="text-sm text-gray-500">最高分</p>
                        <p id="highScore" class="text-xl font-bold text-warning">999:99</p>
                    </div>
                </div>
            </div>

            <!-- 控制说明 -->
            <div class="space-y-2 pt-2 border-t">
                <h3 class="font-medium text-gray-700">操作说明</h3>
                <div class="bg-gray-50 rounded-lg p-3 text-sm space-y-1">
                    <p><i class="fa fa-hand-pointer-o mr-2"></i> 点击相邻数字移动</p>
                    <p><i class="fa fa-arrows mr-2"></i> 或使用方向键移动</p>
                    <p><i class="fa fa-random mr-2"></i> 重新打乱拼图</p>
                </div>
            </div>

            <!-- 保存记录按钮 -->
            <div class="pt-4">
                <button id="saveRecordBtn"
                        class="w-full bg-primary text-white py-3 rounded-lg btn-hover flex items-center justify-center gap-2">
                    <i class="fa fa-save"></i>
                    <span>保存游戏记录</span>
                </button>
            </div>
        </div>

        <!-- 游戏区域 -->
        <div class="flex-1 flex justify-center items-center">
            <div class="bg-white p-6 rounded-xl shadow-lg">
                <div id="gameContainer" class="puzzle-grid rounded-lg p-2" style="width: 335px; height: 335px;"></div>
            </div>

            <!-- 游戏提示 -->
            <div id="gameMessage" class="mt-6 bg-white rounded-xl shadow p-4 text-center max-w-md hidden">
                <i class="fa fa-trophy text-4xl text-yellow-500 mb-3"></i>
                <h3 class="font-semibold text-xl mb-2">恭喜完成！</h3>
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div>
                        <p class="text-sm text-gray-500">用时</p>
                        <p id="finalTime" class="text-xl font-bold text-secondary">00:00</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-500">步数</p>
                        <p id="finalMoves" class="text-xl font-bold text-primary">0</p>
                    </div>
                </div>
                <button id="continueBtn" class="bg-primary text-white px-6 py-2 rounded-lg btn-hover">
                    继续游戏
                </button>
            </div>
        </div>
    </main>

    <!-- 页脚 -->
    <footer class="mt-12 text-center text-gray-500 text-sm">
        <p>数字华容道 &copy; 2025</p>
    </footer>
</div>

<script th:inline="javascript">
    // 游戏状态变量
    let BOARD_SIZE = 3; // 默认3×3
    let board = [];
    let emptyPosition = {row: 0, col: 0};
    let moves = 0;
    let startTime = null;
    let timer = null;
    let seconds = 0;
    let highScores = {}; // 存储不同难度的最高分
    let gameActive = false;
    let isImageMode = false; // 是否为图片模式
    let selectedImage = null; // 选中的图片
    let imageCanvas = null; // 图片画布

    // DOM 元素
    const gameContainer = document.getElementById('gameContainer');
    const movesElement = document.getElementById('moves');
    const timeElement = document.getElementById('time');
    const highScoreElement = document.getElementById('highScore');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const hintBtn = document.getElementById('hintBtn');
    const easyBtn = document.getElementById('easyBtn');
    const mediumBtn = document.getElementById('mediumBtn');
    const numberModeBtn = document.getElementById('numberModeBtn');
    const imageModeBtn = document.getElementById('imageModeBtn');
    const imageUploadSection = document.getElementById('imageUploadSection');
    const imageInput = document.getElementById('imageInput');
    const imagePreview = document.getElementById('imagePreview');
    const hardBtn = document.getElementById('hardBtn');
    const extremeBtn = document.getElementById('extremeBtn');
    const saveRecordBtn = document.getElementById('saveRecordBtn');
    const gameMessage = document.getElementById('gameMessage');
    const finalTimeElement = document.getElementById('finalTime');
    const finalMovesElement = document.getElementById('finalMoves');
    const continueBtn = document.getElementById('continueBtn');
    const BASE = /*[[@{/}]]*/ '';
    // 修复游戏卡片的点击事件
    document.querySelectorAll('.game-card').forEach(card => {
        card.addEventListener('click', function () {
            const gamePath = this.getAttribute('data-game-path');
            if (gamePath) {
                window.location.href = BASE + gamePath;
            }
        });
    });

    // 初始化游戏
    function initializeGame() {
        // 创建目标棋盘
        board = [];
        let counter = 1;
        for (let i = 0; i < BOARD_SIZE; i++) {
            board[i] = [];
            for (let j = 0; j < BOARD_SIZE; j++) {
                if (i === BOARD_SIZE - 1 && j === BOARD_SIZE - 1) {
                    board[i][j] = 0; // 空格
                    emptyPosition = {row: i, col: j};
                } else {
                    board[i][j] = counter++;
                }
            }
        }

        // 重置游戏状态
        moves = 0;
        seconds = 0;
        gameActive = false;

        // 更新UI
        updateGameInfo();
        renderBoard();
        stopTimer();
        gameMessage.classList.add('hidden');

        // 加载最高分
        loadHighScores();
        updateHighScoreDisplay();
    }

    // 渲染棋盘
    function renderBoard() {
        gameContainer.innerHTML = '';

        // 设置网格样式
        gameContainer.style.gridTemplateColumns = `repeat(${BOARD_SIZE}, 1fr)`;
        gameContainer.style.gridTemplateRows = `repeat(${BOARD_SIZE}, 1fr)`;

        // 计算方块大小
        const maxSize = Math.min(336, window.innerWidth - 40);
        const tileSize = Math.floor(maxSize / BOARD_SIZE);
        const containerSize = tileSize * BOARD_SIZE;
        gameContainer.style.width = '100%';
        gameContainer.style.height = '100%';
        gameContainer.style.aspectRatio = '1/1';

        // 创建方块
        for (let i = 0; i < BOARD_SIZE; i++) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                const tile = document.createElement('div');
                const value = board[i][j];

                // 设置方块样式
                tile.className = 'puzzle-tile rounded-lg flex items-center justify-center';
                tile.style.width = `${tileSize}px`;
                tile.style.height = `${tileSize}px`;

                if (value === 0) {
                    // 空格
                    tile.className += ' empty bg-transparent';
                } else {
                    // 数字或图片方块
                    tile.className += ' bg-white shadow-md text-dark';
                    
                    // 修复数字模式下的样式，确保16个格子不会凸出来
                if (isImageMode && selectedImage) {
                        // 图片模式
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        canvas.width = tileSize - 4;
                        canvas.height = tileSize - 4;
                        canvas.style.width = '100%';
                        canvas.style.height = '100%';
                        canvas.style.objectFit = 'cover';
                        
                        // 计算图片片段位置
                        const pieceWidth = selectedImage.width / BOARD_SIZE;
                        const pieceHeight = selectedImage.height / BOARD_SIZE;
                        const srcRow = Math.floor((value - 1) / BOARD_SIZE);
                        const srcCol = (value - 1) % BOARD_SIZE;
                        
                        ctx.drawImage(
                            selectedImage,
                            srcCol * pieceWidth, srcRow * pieceHeight, pieceWidth, pieceHeight,
                            0, 0, canvas.width, canvas.height
                        );
                        
                        tile.appendChild(canvas);
                    } else {
                        // 数字模式
                        tile.style.fontSize = `${Math.min(24, tileSize / 3)}px`;
                        tile.style.fontWeight = 'bold';
                        tile.textContent = value;
                    }

                    // 添加点击事件和更好的布局样式
                    tile.style.boxSizing = 'border-box';
                    tile.style.padding = '2px';
                    tile.addEventListener('click', () => moveTile(i, j));
                }

                gameContainer.appendChild(tile);
            }
        }
    }

    // 更新游戏信息
    function updateGameInfo() {
        movesElement.textContent = moves;
        timeElement.textContent = formatTime(seconds);
    }

    // 格式化时间
    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    // 打乱棋盘
    function shuffleBoard() {
        // 先确保棋盘是可解的
        do {
            // Fisher-Yates 洗牌算法
            const flatBoard = board.flat();
            for (let i = flatBoard.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [flatBoard[i], flatBoard[j]] = [flatBoard[j], flatBoard[i]];
            }

            // 重新构建棋盘
            let index = 0;
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    board[i][j] = flatBoard[index++];
                    if (board[i][j] === 0) {
                        emptyPosition = {row: i, col: j};
                    }
                }
            }
        } while (!isSolvable() || isSolved());

        // 重置游戏状态
        moves = 0;
        seconds = 0;
        gameActive = true;

        // 更新UI
        updateGameInfo();
        renderBoard();
        startTimer();
    }

    // 检查棋盘是否可解
    function isSolvable() {
        const inversions = countInversions();

        if (BOARD_SIZE % 2 === 1) {
            // 奇数大小的棋盘，逆序数为偶数时可解
            return inversions % 2 === 0;
        } else {
            // 偶数大小的棋盘，需要考虑空格所在的行数
            const emptyRowFromBottom = BOARD_SIZE - emptyPosition.row;
            if (emptyRowFromBottom % 2 === 1) {
                return inversions % 2 === 0;
            } else {
                return inversions % 2 === 1;
            }
        }
    }

    // 计算逆序数
    function countInversions() {
        const flatBoard = board.flat().filter(val => val !== 0);
        let inversions = 0;

        for (let i = 0; i < flatBoard.length - 1; i++) {
            for (let j = i + 1; j < flatBoard.length; j++) {
                if (flatBoard[i] > flatBoard[j]) {
                    inversions++;
                }
            }
        }

        return inversions;
    }

    // 移动方块
    function moveTile(row, col) {
        if (!gameActive) return;

        // 检查是否与空格相邻
        const isAdjacent = (
            (Math.abs(row - emptyPosition.row) === 1 && col === emptyPosition.col) ||
            (Math.abs(col - emptyPosition.col) === 1 && row === emptyPosition.row)
        );

        if (!isAdjacent) return;

        // 移动方块
        board[emptyPosition.row][emptyPosition.col] = board[row][col];
        board[row][col] = 0;
        emptyPosition = {row, col};

        // 更新步数
        moves++;
        movesElement.textContent = moves;

        // 重新渲染
        renderBoard();

        // 检查是否完成
        if (isSolved()) {
            gameCompleted();
        }
    }

    // 检查是否完成
    function isSolved() {
        let expected = 1;

        for (let i = 0; i < BOARD_SIZE; i++) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                if (i === BOARD_SIZE - 1 && j === BOARD_SIZE - 1) {
                    // 最后一个位置应该是0
                    if (board[i][j] !== 0) return false;
                } else {
                    if (board[i][j] !== expected++) return false;
                }
            }
        }

        return true;
    }

    // 游戏完成
    function gameCompleted() {
        gameActive = false;
        stopTimer();

        // 检查是否为新的最高分
        const key = `${BOARD_SIZE}x${BOARD_SIZE}`;
        if (!highScores[key] || seconds < highScores[key]) {
            highScores[key] = seconds;
            saveHighScores();
            updateHighScoreDisplay();
        }

        // 显示完成消息
        finalTimeElement.textContent = formatTime(seconds);
        finalMovesElement.textContent = moves;
        gameMessage.classList.remove('hidden');
        
        // 自动保存游戏记录到数据库
        saveGameRecord();
    }

    // 获取提示
    function showHint() {
        // 简单提示：找出可移动的方块
        const possibleMoves = [];

        const directions = [
            {row: -1, col: 0}, // 上
            {row: 1, col: 0},  // 下
            {row: 0, col: -1}, // 左
            {row: 0, col: 1}   // 右
        ];

        for (const dir of directions) {
            const row = emptyPosition.row + dir.row;
            const col = emptyPosition.col + dir.col;

            if (row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE) {
                possibleMoves.push({row, col});
            }
        }

        // 高亮显示可移动的方块
        if (possibleMoves.length > 0) {
            const tiles = gameContainer.querySelectorAll('.puzzle-tile');
            tiles.forEach((tile, index) => {
                const row = Math.floor(index / BOARD_SIZE);
                const col = index % BOARD_SIZE;

                for (const move of possibleMoves) {
                    if (move.row === row && move.col === col) {
                        tile.classList.add('bg-puzzle-active', 'text-white');
                        setTimeout(() => {
                            tile.classList.remove('bg-puzzle-active', 'text-white');
                            tile.classList.add('bg-white', 'text-dark');
                        }, 2000);
                    }
                }
            });
        }
    }

    // 开始计时器
    function startTimer() {
        if (timer) clearInterval(timer);

        timer = setInterval(() => {
            if (gameActive) {
                seconds++;
                timeElement.textContent = formatTime(seconds);
            }
        }, 1000);
    }

    // 停止计时器
    function stopTimer() {
        if (timer) {
            clearInterval(timer);
            timer = null;
        }
    }

    // 设置难度
    function setDifficulty(size) {
        BOARD_SIZE = size;
        initializeGame();

        // 更新按钮状态
        [mediumBtn, hardBtn, extremeBtn].forEach(btn => {
            btn.className = 'bg-gray-200 hover:bg-gray-300 py-1 rounded btn-hover';
        });

        if (size === 3) {
            mediumBtn.className = 'bg-yellow-500 text-white py-1 rounded btn-hover';
        } else if (size === 4) {
            hardBtn.className = 'bg-red-500 text-white py-1 rounded btn-hover';
        } else if (size === 5) {
            extremeBtn.className = 'bg-purple-600 text-white py-1 rounded btn-hover';
        }
    }

    // 保存最高分
    function saveHighScores() {
        localStorage.setItem('puzzleHighScores', JSON.stringify(highScores));
    }

    // 加载最高分
    function loadHighScores() {
        const saved = localStorage.getItem('puzzleHighScores');
        if (saved) {
            highScores = JSON.parse(saved);
        }
    }

    // 更新最高分显示
    function updateHighScoreDisplay() {
        const key = `${BOARD_SIZE}x${BOARD_SIZE}`;
        if (highScores[key]) {
            highScoreElement.textContent = formatTime(highScores[key]);
        } else {
            highScoreElement.textContent = '--:--';
        }
    }

    // 保存游戏记录
    function saveGameRecord() {
        // 确保游戏已完成才保存记录
        if (gameActive) {
            alert('请完成游戏后再保存记录！');
            return;
        }
        
        // 构建请求数据
        const gameRecord = {
            gameType: 'puzzle',
            score: calculateScore(),
            level: `${BOARD_SIZE}x${BOARD_SIZE}`,
            duration: seconds
        };
        
        // 发送请求到后端API
        fetch(BASE + 'api/game/record', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(gameRecord)
        })
        .then(response => {
            return response.json().then(data => {
                // 即使状态码不是200，也解析响应体
                if (!response.ok) {
                    throw new Error(data.message || '保存失败');
                }
                return data;
            });
        })
        .then(data => {
            const difficulty = BOARD_SIZE === 2 ? '简单' : BOARD_SIZE === 3 ? '中等' : BOARD_SIZE === 4 ? '困难' : '极限';
            alert(`游戏记录已成功保存到数据库！\n难度: ${difficulty}\n用时: ${formatTime(seconds)}\n步数: ${moves}\n得分: ${gameRecord.score}`);
        })
        .catch(error => {
            console.error('保存游戏记录失败:', error);
            alert(error.message || '保存游戏记录失败，请重试！');
        });
    }
    
    // 计算得分 (基于时间和步数的综合评分)
    function calculateScore() {
        // 基础分数 1000 分，时间每多1秒减1分，步数每多1步减2分
        const baseScore = 1000;
        const timePenalty = seconds * 1;
        const movePenalty = moves * 2;
        return Math.max(0, baseScore - timePenalty - movePenalty);
    }

    // 继续游戏
    function continueGame() {
        gameMessage.classList.add('hidden');
        shuffleBoard();
    }

    // 处理键盘事件
    function handleKeyDown(e) {
        if (!gameActive) return;

        let newRow = emptyPosition.row;
        let newCol = emptyPosition.col;

        switch (e.key) {
            case 'ArrowUp':
                // 上箭头：空格向上移动（相当于方块向下移动）
                newRow++;
                break;
            case 'ArrowDown':
                // 下箭头：空格向下移动（相当于方块向上移动）
                newRow--;
                break;
            case 'ArrowLeft':
                // 左箭头：空格向左移动（相当于方块向右移动）
                newCol++;
                break;
            case 'ArrowRight':
                // 右箭头：空格向右移动（相当于方块向左移动）
                newCol--;
                break;
            default:
                return;
        }

        // 检查新位置是否有效
        if (newRow >= 0 && newRow < BOARD_SIZE && newCol >= 0 && newCol < BOARD_SIZE) {
            moveTile(newRow, newCol);
        }
    }

    // 图片处理函数
    function switchToNumberMode() {
        isImageMode = false;
        numberModeBtn.className = 'bg-blue-500 text-white py-1 rounded btn-hover';
        imageModeBtn.className = 'bg-gray-200 hover:bg-gray-300 py-1 rounded btn-hover';
        imageUploadSection.classList.add('hidden');
        renderBoard();
    }

    function switchToImageMode() {
        isImageMode = true;
        numberModeBtn.className = 'bg-gray-200 hover:bg-gray-300 py-1 rounded btn-hover';
        imageModeBtn.className = 'bg-blue-500 text-white py-1 rounded btn-hover';
        imageUploadSection.classList.remove('hidden');
        if (selectedImage) {
            renderBoard();
        }
    }

    function handleImageUpload(event) {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    selectedImage = img;
                    
                    // 显示预览
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 128;
                    canvas.height = 128;
                    
                    // 计算缩放比例以适应预览区域
                    const scale = Math.min(128 / img.width, 128 / img.height);
                    const scaledWidth = img.width * scale;
                    const scaledHeight = img.height * scale;
                    const offsetX = (128 - scaledWidth) / 2;
                    const offsetY = (128 - scaledHeight) / 2;
                    
                    ctx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);
                    
                    imagePreview.innerHTML = '';
                    imagePreview.appendChild(canvas);
                    
                    // 如果当前是图片模式，重新渲染棋盘
                    if (isImageMode) {
                        renderBoard();
                    }
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    }

    // 事件监听
    document.addEventListener('keydown', handleKeyDown);
    shuffleBtn.addEventListener('click', shuffleBoard);
    hintBtn.addEventListener('click', showHint);
    mediumBtn.addEventListener('click', () => setDifficulty(3));
    hardBtn.addEventListener('click', () => setDifficulty(4));
    extremeBtn.addEventListener('click', () => setDifficulty(5));
    saveRecordBtn.addEventListener('click', saveGameRecord);
    continueBtn.addEventListener('click', continueGame);
    numberModeBtn.addEventListener('click', switchToNumberMode);
    imageModeBtn.addEventListener('click', switchToImageMode);
    imageInput.addEventListener('change', handleImageUpload);

    // 窗口大小变化时重新渲染棋盘
    window.addEventListener('resize', renderBoard);

    // 初始化游戏并设置默认难度为中等
    initializeGame();
    setDifficulty(3);
</script>
</body>
</html>